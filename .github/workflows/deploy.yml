# =================================================================
# GitOps Deploy Workflow
# =================================================================
# Trunk-based development with automatic deployments:
#   - feature/* branches → DEV (auto)
#   - main branch → STAGING (auto)
#   - tags v* → PRODUCTION (manual with confirmation)
# =================================================================

name: Deploy

on:
  push:
    branches:
      - 'feature/**'   # Auto-deploy to DEV
      - 'main'         # Auto-deploy to STAGING

  workflow_dispatch:    # Manual PRODUCTION deploy
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - production
      version:
        description: 'Git tag to deploy (e.g., v1.0.0)'
        required: true
        type: string
      confirm:
        description: 'Type DEPLOY to confirm production deployment'
        required: true
        type: string

# Least-privilege default token permissions
permissions:
  contents: read

# Cancel in-progress runs for the same branch
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # =================================================================
  # Determine Environment
  # =================================================================
  determine-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.env }}
      deploy_ref: ${{ steps.set-env.outputs.deploy_ref }}
    steps:
      - name: Determine target environment
        id: set-env
        run: |
          set -euo pipefail
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "env=production" >> $GITHUB_OUTPUT
            echo "deploy_ref=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "env=staging" >> $GITHUB_OUTPUT
            echo "deploy_ref=${{ github.sha }}" >> $GITHUB_OUTPUT
          else
            echo "env=dev" >> $GITHUB_OUTPUT
            echo "deploy_ref=${{ github.sha }}" >> $GITHUB_OUTPUT
          fi

      - name: Validate production confirmation
        if: github.event_name == 'workflow_dispatch'
        run: |
          set -euo pipefail
          if [[ "${{ github.event.inputs.confirm }}" != "DEPLOY" ]]; then
            echo "::error::Production deployment requires typing 'DEPLOY' to confirm"
            exit 1
          fi

  # =================================================================
  # Deploy
  # =================================================================
  deploy:
    needs: determine-environment
    runs-on: ubuntu-latest
    environment: ${{ needs.determine-environment.outputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # For production, checkout the specified tag. For pushes, deploy the triggering commit SHA.
          ref: ${{ needs.determine-environment.outputs.deploy_ref }}
          fetch-depth: 0

      # =================================================================
      # Install cloudflared for SSH tunneling
      # =================================================================
      - name: Install cloudflared
        run: |
          set -euo pipefail
          sudo mkdir -p --mode=0755 /usr/share/keyrings
          curl -fsSL https://pkg.cloudflare.com/cloudflare-main.gpg | sudo tee /usr/share/keyrings/cloudflare-main.gpg >/dev/null
          echo "deb [signed-by=/usr/share/keyrings/cloudflare-main.gpg] https://pkg.cloudflare.com/cloudflared $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/cloudflared.list >/dev/null
          sudo apt-get update
          sudo apt-get install -y cloudflared
          cloudflared --version

      # =================================================================
      # Configure SSH with Cloudflare Access Service Token
      # =================================================================
      - name: Configure SSH
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          # Pin server host keys to prevent MITM.
          # Generate on the server with: ./scripts/ssh/print-known-hosts.sh ssh.yourdomain.com
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" > ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts

          cat > ~/.ssh/config << EOF
          Host ${{ secrets.SSH_HOST }}
            ProxyCommand cloudflared access ssh --service-token-id ${{ secrets.CF_SERVICE_TOKEN_ID }} --service-token-secret ${{ secrets.CF_SERVICE_TOKEN_SECRET }} --hostname %h
            IdentityFile ~/.ssh/deploy_key
            User ${{ secrets.SSH_USER }}
            StrictHostKeyChecking yes
            UserKnownHostsFile ~/.ssh/known_hosts
            RequestTTY no
          EOF

          chmod 600 ~/.ssh/config

      # =================================================================
      # Sync (Git Archive) and Deploy via Restricted CI Interface
      # =================================================================
      - name: Sync deployments repo to server (git archive)
        env:
          ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
          DEPLOY_REF: ${{ needs.determine-environment.outputs.deploy_ref }}
        run: |
          set -euo pipefail
          echo "=== Syncing to ${ENVIRONMENT} (ref: ${DEPLOY_REF}) ==="
          # Ship tracked files only (prevents leaking untracked secrets from the runner workspace).
          git archive --format=tar "${DEPLOY_REF}" | gzip -c | ssh "${{ secrets.SSH_HOST }}" "hosting sync ${ENVIRONMENT}"

      # =================================================================
      # Deploy to Server
      # =================================================================
      - name: Deploy
        env:
          ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
          DEPLOY_REF: ${{ needs.determine-environment.outputs.deploy_ref }}
        run: |
          set -euo pipefail
          echo "=== Deploying to ${ENVIRONMENT} (ref: ${DEPLOY_REF}) ==="
          ssh "${{ secrets.SSH_HOST }}" "hosting deploy ${ENVIRONMENT} ${DEPLOY_REF}"

      # =================================================================
      # Post-deploy Health Check
      # =================================================================
      - name: Health check
        if: success()
        env:
          ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
        run: |
          set -euo pipefail
          echo "Waiting for services to start..."
          sleep 10
          ssh "${{ secrets.SSH_HOST }}" "hosting status ${ENVIRONMENT}"

      # =================================================================
      # Notify on Failure
      # =================================================================
      - name: Notify on failure
        if: failure()
        run: |
          echo "::error::Deployment to ${{ needs.determine-environment.outputs.environment }} failed!"
          # Add Slack/Discord notification here if needed
          # curl -X POST -H 'Content-type: application/json' \
          #   --data '{"text":"Deployment failed: ${{ github.repository }} to ${{ needs.determine-environment.outputs.environment }}"}' \
          #   ${{ secrets.SLACK_WEBHOOK }}

# =================================================================
# Required GitHub Secrets (per environment)
# =================================================================
# SSH_PRIVATE_KEY      - Ed25519 private key for appmgr user
# SSH_HOST             - e.g., ssh.yourdomain.com
# SSH_USER             - e.g., appmgr
# SSH_KNOWN_HOSTS      - known_hosts entry/entries for SSH_HOST (pin host key)
# CF_SERVICE_TOKEN_ID  - Cloudflare Access service token ID
# CF_SERVICE_TOKEN_SECRET - Cloudflare Access service token secret
#
# =================================================================
# GitHub Environment Setup
# =================================================================
# Create 3 environments in repo Settings > Environments:
#   - dev (no protection rules)
#   - staging (optional: require status checks)
#   - production (require manual approval + reviewers)
# =================================================================

# =================================================================
# App Template - Docker Compose Configuration
# =================================================================
# Modern Docker Compose v2 syntax with 2025 security standards
# Uses file-based secrets pattern (same security as Docker Swarm)
# Copy this template for your own apps
# =================================================================

services:
  app:
    # Your app image
    # Use a pinned version tag or digest. Avoid :latest in production.
    image: ghcr.io/your-org/your-app:1.0.0

    # On-VM builds are discouraged and blocked by the hardened GitOps deploy tool by default.
    # If you really need on-host builds, set ALLOW_BUILD=1 in:
    #   /etc/hosting-blueprint/deploy-policy.env   (root-owned)
    # build:
    #   context: .
    #   dockerfile: Dockerfile

    # Container name (uses environment variable)
    container_name: app-${ENVIRONMENT}

    # Restart policy
    restart: unless-stopped
    init: true
    stop_grace_period: 30s

    # =================================================================
    # Security Hardening (2025 Standards)
    # =================================================================
    security_opt:
      # Prevent privilege escalation
      - no-new-privileges:true

    # Drop ALL Linux capabilities, then add only what's needed
    cap_drop:
      - ALL
    # Uncomment capabilities your app actually needs:
    # cap_add:
    #   - NET_BIND_SERVICE  # Bind to ports < 1024
    #   - CHOWN             # Change file ownership
    #   - SETGID            # Change GID
    #   - SETUID            # Change UID

    # Prefer a read-only filesystem. Set to false if your app must write to disk.
    read_only: true

    # If read_only is true, add tmpfs for writable temp space
    tmpfs:
      - /tmp:size=64M,mode=1777
    # Some apps need /var/run too:
    # - /var/run

    # Fork-bomb protection
    pids_limit: 200

    # =================================================================
    # Resource Limits (Prevent abuse)
    # =================================================================
    deploy:
      resources:
        limits:
          cpus: '1.0'      # Max 1 CPU core
          memory: 512M      # Max 512MB RAM
        reservations:
          cpus: '0.25'      # Reserved 0.25 CPU
          memory: 128M      # Reserved 128MB RAM

    # =================================================================
    # Health Check
    # =================================================================
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:${APP_PORT}/health"]
      # Or for Node.js apps:
      # test: ["CMD", "node", "-e", "require('http').get('http://localhost:${APP_PORT}/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

    # =================================================================
    # Logging (Prevent disk exhaustion)
    # =================================================================
    # The VM config already sets Docker's daemon-wide log rotation.
    # This is an extra, per-service defense-in-depth.
    logging:
      driver: "local"
      options:
        max-size: "20m"
        max-file: "5"

    # =================================================================
    # Environment Variables
    # =================================================================
    environment:
      - NODE_ENV=${NODE_ENV}
      - PORT=${APP_PORT}
      # Add your app-specific environment variables here
      # - DATABASE_URL=${DATABASE_URL}

      # =================================================================
      # File-Based Secrets Pattern
      # =================================================================
      # Point to secret files mounted at /run/secrets/
      # Your app reads the file content at startup
      # This keeps secrets OUT of environment variables (more secure)
      #
      # Example: DATABASE_PASSWORD_FILE=/run/secrets/db_password
      # Your app code: fs.readFileSync(process.env.DATABASE_PASSWORD_FILE, 'utf8').trim()
      # =================================================================
      - DATABASE_PASSWORD_FILE=/run/secrets/db_password
      - API_KEY_FILE=/run/secrets/api_key
      # - JWT_SECRET_FILE=/run/secrets/jwt_secret
      # - SMTP_PASSWORD_FILE=/run/secrets/smtp_password

    # If your container runs as non-root, it still needs to read secret files.
    # The setup uses a dedicated host group "hosting-secrets" (GID 1999) and
    # secrets stored as root:hosting-secrets with mode 640.
    group_add:
      - "1999"

    # Load additional variables from .env file
    env_file:
      - .env

    # =================================================================
    # Volumes - Including Secret Files
    # =================================================================
    volumes:
      # =================================================================
      # Secret files (from /var/secrets - never in git)
      # =================================================================
      # Mount secrets as read-only files to /run/secrets/
      # Create secrets with: ./scripts/secrets/create-secret.sh <env> <name>
      # =================================================================
      - /var/secrets/${ENVIRONMENT}/db_password.txt:/run/secrets/db_password:ro
      - /var/secrets/${ENVIRONMENT}/api_key.txt:/run/secrets/api_key:ro
      # - /var/secrets/${ENVIRONMENT}/jwt_secret.txt:/run/secrets/jwt_secret:ro
      # - /var/secrets/${ENVIRONMENT}/smtp_password.txt:/run/secrets/smtp_password:ro

      # =================================================================
      # App data volumes (uncomment if needed)
      # =================================================================
      # - ./data:/app/data:rw
      # - ./uploads:/app/uploads:rw

    # =================================================================
    # Networks
    # =================================================================
    # NOTE: Update the network name to match the one defined below
    networks:
      - staging-web  # <-- Change this to match your environment

    # =================================================================
    # Labels (for Prometheus monitoring - optional)
    # =================================================================
    labels:
      - "app.name=${APP_NAME}"
      - "app.environment=${ENVIRONMENT}"
      # Uncomment if you want Prometheus to scrape this app
      # - "prometheus.scrape=true"
      # - "prometheus.port=${APP_PORT}"
      # - "prometheus.path=/metrics"

# =================================================================
# Networks (External - created via scripts/create-networks.sh)
# =================================================================
# NOTE: Update the network name below to match your DOCKER_NETWORK env var.
# Docker Compose doesn't support variable interpolation in network keys.
#
# For dev:        use "dev-web"
# For staging:    use "staging-web"
# For production: use "prod-web"
# =================================================================
networks:
  staging-web:  # <-- Change this to match your environment
    external: true

# =================================================================
# Volumes (if needed)
# =================================================================
# volumes:
#   app_data:
#     name: ${APP_NAME}_data
